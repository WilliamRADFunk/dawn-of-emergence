<html>

<head>
	<!-- Resets all default browser stylings for a clean slate -->
    <link rel="stylesheet" href="css/reset_author_richard_clark.css">
    <!-- Styles specific to the Encryptor pages -->
    <link rel="stylesheet" href="css/styles.css">
    <!-- WebGL wrapper library -->
	<script src="js/external/three.js"></script>
	<!-- Allows for keyboard listeners -->
	<script src="js/external/threex.keyboardstate.js"></script>
	<script id="worker" type="javascript/worker">
		self.onmessage = function(e) 
		{
			if( e.data.type == 'load-music' )
			{
				self.postMessage({'type':'Web worker says, "Music load is complete."'});
			}
		}
	</script>
	<script>
		var camera, scene, renderer, WIDTH, HEIGHT;
		var earth, clouds, beacon, updateCounter = 0;
		function init()
		{
			var blob = new Blob([document.getElementById('worker').textContent]); 
			var worker = new Worker( window.URL.createObjectURL( blob ) );

			WIDTH = window.innerWidth;
			HEIGHT = window.innerHeight;

			scene = new THREE.Scene();

			var backgroundMusic = new Audio("assets/audio/mahler_05.mp3");
			backgroundMusic.autoplay = true;
			backgroundMusic.loop = true;
			worker.postMessage({'type':'load-music'});

			worker.onmessage = function(e) 
			{
				console.log(e.data.type);
			}

			// The Universe in all its stary awesomeness.
			var starsGeometry = new THREE.SphereGeometry(90, 32, 32);
			var starsMaterial = new THREE.MeshBasicMaterial();
			starsMaterial.map = THREE.ImageUtils.loadTexture('assets/images/galaxy_starfield.png');
			starsMaterial.map.minFilter = THREE.LinearFilter;
			starsMaterial.map.wrapS = THREE.RepeatWrapping;
			starsMaterial.map.wrapT = THREE.RepeatWrapping;
			starsMaterial.map.repeat.set( 16, 8 );
			starsMaterial.side = THREE.BackSide;
			var stars = new THREE.Mesh(starsGeometry, starsMaterial);
			scene.add(stars);
			// The Earth: its water, landmasses, and textured elevations.
			var earthGeometry = new THREE.SphereGeometry(0.5, 32, 32);
			var earthMaterial = new THREE.MeshPhongMaterial();
			earthMaterial.map = THREE.ImageUtils.loadTexture('assets/images/earthmap1k.jpg');
			earthMaterial.map.minFilter = THREE.LinearFilter;
			earthMaterial.bumpMap = THREE.ImageUtils.loadTexture('assets/images/earthbump1k.jpg');
			earthMaterial.bumpMap.minFilter = THREE.LinearFilter;
			earthMaterial.bumpScale = 0.02;
			earthMaterial.specularMap = THREE.ImageUtils.loadTexture('assets/images/earthspec1k.jpg');
			earthMaterial.specularMap.minFilter = THREE.LinearFilter;
			earthMaterial.specular  = new THREE.Color(0xFFFFFF);
			earthMaterial.shininess = 10;
			earth = new THREE.Mesh(earthGeometry, earthMaterial);
			scene.add(earth);
			// Rotating cloudcover.
			var cloudsGeometry = new THREE.SphereGeometry(0.503, 32, 32);
			var cloudsMaterial = new THREE.MeshPhongMaterial();
			cloudsMaterial.map = THREE.ImageUtils.loadTexture('assets/images/earthcloudmap_modified.png');
			cloudsMaterial.map.minFilter = THREE.LinearFilter;
			cloudsMaterial.side = THREE.FrontSide;
			cloudsMaterial.opacity = 0.9;
			cloudsMaterial.transparent = true;
			cloudsMaterial.depthWrite = false;
			clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
			earth.add(clouds);
			// Moon's orbital mechanics
			moonOrbit = new THREE.Object3D();
			scene.add( moonOrbit );
			var moonOrbitalPivot = new THREE.Object3D();
			moonOrbitalPivot.rotation.y = 0;
			moonOrbit.add( moonOrbitalPivot );
			// Moon mesh
			var moonGeometry = new THREE.SphereGeometry(0.5, 32, 32);
			var moonMaterial = new THREE.MeshPhongMaterial();
			moonMaterial.map = THREE.ImageUtils.loadTexture('assets/images/moonmap1k.jpg');
			moonMaterial.map.minFilter = THREE.LinearFilter;
			moonMaterial.bumpMap = THREE.ImageUtils.loadTexture('assets/images/moonbump1k.jpg');
			moonMaterial.bumpMap.minFilter = THREE.LinearFilter;
			moonMaterial.bumpScale = 0.02;
			var moon = new THREE.Mesh( moonGeometry, moonMaterial );
			moon.position.z = 30;
			moonOrbitalPivot.add( moon );
			// The satellite's viewpoint.
			camera = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 0.01, 1000 );
			camera.position.x = earth.position.x;
			camera.position.y = earth.position.y + 0.7;
			camera.position.z = earth.position.z - 3;
			camera.lookAt( earth.position );
			// Three.js renderer.
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor( 0x000000, 0 );
			renderer.setSize( WIDTH, HEIGHT );
			renderer.autoClear = false;
			// Two lightsources: one as an every glow, and the other simulating the sun's brightness. 
			scene.add(new THREE.AmbientLight(0x333333));
		    var Sun = new THREE.DirectionalLight( 0x777777, 1 );
		    Sun.position.x = earth.position.x - 80;
		    Sun.position.y = earth.position.y + 70;
		    Sun.position.z = earth.position.z - 100;
		    scene.add(Sun);
		    //Satellite bodies			
			var satellites = new THREE.Object3D();
			var satelliteGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
			var satelliteMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
			var satellite01 = new THREE.Mesh( satelliteGeometry, satelliteMaterial );
			satellite01.position.x = earth.position.x - 1.3;
			satellite01.position.y = earth.position.y;
			satellite01.position.z = earth.position.z;
			beacon = new THREE.SpotLight( 0xFF0000 );
		    beacon.position.x = earth.position.x - 1.15;
			beacon.position.y = earth.position.y;
			beacon.position.z = earth.position.z;
			beacon.target = satellite01;
			scene.add(beacon);
			satellites.add( satellite01 );
			scene.add(satellites);
		    // Resizes Three.js, HTML, and CSS elements with a change in window size.
		    window.addEventListener( 'resize', onWindowResize, false);
		    // Contains the 1st POV, and all HUD elements.
			var container = document.getElementById("mainview");
			document.body.appendChild( container );
			container.appendChild( renderer.domElement );
			// Activates the update loop.
		    render();
		}
		// Resizes Three.js, HTML, and CSS elements with a change in window size.
		function onWindowResize()
		{
			WIDTH = window.innerWidth;
			HEIGHT = window.innerHeight;
			renderer.setSize( WIDTH, HEIGHT );
			camera.aspect = WIDTH / HEIGHT;
			camera.updateProjectionMatrix();
		}
		// The update loop.
		function render()
		{
			updateCounter++;
			if(updateCounter % 60 == 0)
			{
				if(beacon.intensity != 0)
				{
					beacon.intensity = 0;
				}
				else
				{
					beacon.intensity = 1;
				}
			}
			moonOrbit.rotation.y += 0.0002;
			earth.rotation.y += 0.0005;
			clouds.rotation.y += 0.0005;
			requestAnimationFrame( render );
			renderer.render( scene, camera );
		}
	</script>
</head>

<body>

<div id="container">
	<div id="mainview">
		<div id="top-left"></div>
		<div id="top-center"></div>
		<div id="top-right"></div>
		<div id="middle-left"></div>
		<div id="middle-right"></div>
		<div id="bottom-left"></div>
		<div id="bottom-center"></div>
		<div id="bottom-right">
			<button id="btn-settings"></button>
		</div>
	</div>
</div>

<script>window.onload = init;</script>

<script>
</script>

</body>

</html>

<!--
	* Planetoids, stary backdrop, and cloud-cover came from http://planetpixelemporium.com/earth.html
	  with a copyright license that allowed:

	  	"Example 1 - The Simulator or Game
		You are a software author who has created a Solar System simulator and you want to use my planet texture maps in your program. Since the primary intent of your use is to create real time renderings utilizing the planet texture maps as a resource in your software product, this is an acceptable use under my copyright terms."

	* Symphonic music from https://archive.org/details/uso20080601 with a Attribution-Noncommercial-No Derivative Works 3.0 United States license. Composer is Gustav Mahler. Other credits can be found at the above URL.

-->